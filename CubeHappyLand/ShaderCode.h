#pragma once

// color and position
const char* vertexShaderSource = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aCol;\n"
"out vec3 myColor;\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(aPos, 1.0f);\n"
"	myColor = aCol;\n"
"}\n";
const char* fragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec3 myColor;\n"
"void main()\n"
"{\n"
"	FragColor = vec4(myColor, 1.0f);\n"
"}\n";
// with texture
const char* vss_cube = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec2 aTexCoord;\n"
"out vec2 TexCoord;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"void main()\n"
"{\n"
"	gl_Position = projection * view * model * vec4(aPos, 1.0f);\n"
"	TexCoord = aTexCoord;\n"
"}";
const char* fss_cube = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoord;\n"
"uniform sampler2D myTexture;\n"
"void main()\n"
"{\n"
"	FragColor = texture(myTexture, TexCoord);\n"
"}\n";

// gouraud
const char* gouraud_vertex_shader = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoords;\n"
"out VS_OUT {\n"
"	vec3 FragPos;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}vs_out;\n"
"out vec3 Ambient;\n"
"out vec3 Diffuse;\n"
"out vec3 Specular;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"uniform vec3 viewPos;\n"
"struct Light {\n"
"	vec3 color;\n"
"	vec3 position;\n"
"	vec3 ambient;\n"
"	vec3 diffuse;\n"
"	vec3 specular;\n"
"	float constant;\n"
"	float linear;\n"
"	float quadratic;\n"
"};\n"
"struct Material {\n"
"	float shininess;\n"
"};\n"
"uniform float ambientFactor;\n"
"uniform float diffuseFactor;\n"
"uniform float specularFactor;\n"
"uniform Light light;\n"
"uniform Material material;\n"
"void main() {\n"
"	vs_out.FragPos = vec3(model * vec4(aPos, 1.0f));\n"
"	gl_Position = projection * view * vec4(vs_out.FragPos, 1.0f);\n"
"	vec3 Normal = mat3(transpose(inverse(model))) * aNormal;\n"
"	vs_out.TexCoords = aTexCoords;\n"
// calculate ambient with diffuse texture (surely you can also use an ambient texture)
"	Ambient = light.ambient * light.color;\n"
// calculate normal and light direction
"	vec3 normal = normalize(Normal);\n"
"	vec3 lightDirection = normalize(light.position - vs_out.FragPos);\n"
// calculate diffuse component with diffuse texture
"	float diffuseStrength = max(dot(normal, lightDirection), 0.0f);\n"
"	Diffuse = light.diffuse * (diffuseStrength * light.color);\n"
// calculate specular with specular texture
"	vec3 viewDirection = normalize(viewPos - vs_out.FragPos);\n"
"	vec3 reflectDirection = normalize(reflect(-lightDirection, normal));\n"
"	float specularStrength = pow(max(dot(viewDirection, reflectDirection), 0.0f), material.shininess);\n"
"	Specular = light.specular * (specularStrength * light.color * specularFactor);\n"
// calculate attenuation
"	float distance = length(light.position - vs_out.FragPos);\n"
"	float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n"
"	Ambient *= attenuation;\n"
"	Diffuse *= attenuation;\n"
"	Specular *= attenuation;\n"
"}";
const char* gouraud_fragment_shader = "#version 330 core\n"
"in VS_OUT {\n"
"	vec3 FragPos;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}fs_in;\n"
"in vec3 Ambient;\n"
"in vec3 Diffuse;\n"
"in vec3 Specular;\n"
"out vec4 FragColor;\n"
"uniform mat4 lightSpaceMatrix;\n"
"struct Material {\n"
"	sampler2D diffuse;\n"
"	sampler2D specular;\n"
"};\n"
"uniform sampler2D shadowMap;\n"
"uniform Material material;\n"
// calculate shadow
"float ShadowCalculation(vec4 fragPosLightSpace) {\n"
"	vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;"
"	projCoords = projCoords * 0.5 + 0.5;\n"
// closest depth
"	float closetDepth = texture(shadowMap, projCoords.xy).r;\n"
// current depth
"	float currentDepth = projCoords.z;\n"
// set shadow factor to be 
"	float shadow = currentDepth > closetDepth?1.0:0.0;\n"
"	return shadow;"
"}\n"
"void main() {\n"
"	vec3 ambient = Ambient * texture(material.diffuse, fs_in.TexCoords).rgb;\n"
"	vec3 diffuse = Diffuse * texture(material.diffuse, fs_in.TexCoords).rgb;\n"
"	vec3 specular = Specular * texture(material.specular, fs_in.TexCoords).rgb;\n"
// calculate shadow
"	float shadow = ShadowCalculation(fs_in.FragPosLightSpace);\n"
// final fragment's color
"	vec3 result =  ambient + (1.0f - shadow) * (diffuse + specular);\n"
"	FragColor = vec4(result, 1.0f);\n"
"}";

// phong
const char* phong_vertex_shader = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoords;\n"
"out VS_OUT{\n"
"	vec3 FragPos;\n"
"	vec3 Normal;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}vs_out;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"uniform mat4 lightSpaceMatrix;\n"
"void main()\n"
"{\n"
"	vs_out.FragPos = vec3(model * vec4(aPos, 1.0f));\n"
"	gl_Position = projection * view * vec4(vs_out.FragPos, 1.0f);\n"
"	vs_out.Normal = mat3(transpose(inverse(model))) * aNormal;\n"
"	vs_out.TexCoords = aTexCoords;\n"
// transformation from world space into light space
"	vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0);\n"
"}\n";
const char* phong_fragment_shader = "#version 330 core\n"
"in VS_OUT {\n"
"	vec3 FragPos;\n"
"	vec3 Normal;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}fs_in;\n"
"out vec4 FragColor;\n"
"uniform vec3 viewPos;\n"
"struct Light {\n"
"	vec3 color;\n"
"	vec3 position;\n"
"	vec3 ambient;\n"
"	vec3 diffuse;\n"
"	vec3 specular;\n"
"	float constant;\n"
"	float linear;\n"
"	float quadratic;\n"
"};\n"
"struct Material {\n"
"	sampler2D diffuse;\n"
"	sampler2D specular;\n"
"	float shininess;\n"
"};\n"
"uniform sampler2D shadowMap;\n"
"uniform float ambientFactor;\n"
"uniform float diffuseFactor;\n"
"uniform float specularFactor;\n"
"uniform Light light;\n"
"uniform Material material;\n"
// calculate shadow
"float ShadowCalculation(vec4 fragPosLightSpace) {\n"
"	vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;"
"	projCoords = projCoords * 0.5 + 0.5;\n"
// closest depth
"	float closetDepth = texture(shadowMap, projCoords.xy).r;\n"
// current depth
"	float currentDepth = projCoords.z;\n"
// set shadow factor to be 
"	float shadow = currentDepth > closetDepth?1.0:0.0;\n"
"	return shadow;"
"}\n"
"void main()\n"
"{\n"
// calculate ambient with diffuse texture (surely you can also use an ambient texture)
"	vec3 ambient = light.ambient * light.color * texture(material.diffuse, fs_in.TexCoords).rgb;\n"
// calculate normal and light direction
"	vec3 normal = normalize(fs_in.Normal);\n"
"	vec3 lightDirection = normalize(light.position - fs_in.FragPos);\n"
// calculate diffuse component with diffuse texture
"	float diffuseStrength = max(dot(normal, lightDirection), 0.0f);\n"
"	vec3 diffuse = light.diffuse * (diffuseStrength * light.color * texture(material.diffuse, fs_in.TexCoords).rgb);\n"
// calculate specular with specular texture
"	vec3 viewDirection = normalize(viewPos - fs_in.FragPos);\n"
"	vec3 reflectDirection = normalize(reflect(-lightDirection, normal));\n"
"	float specularStrength = pow(max(dot(viewDirection, reflectDirection), 0.0f), material.shininess);\n"
"	vec3 specular = light.specular * (specularStrength * light.color * specularFactor * texture(material.specular, fs_in.TexCoords).rgb);\n"
// calculate attenuation
"	float distance = length(light.position - fs_in.FragPos);\n"
"	float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n"
"	ambient *= attenuation;\n"
"	diffuse *= attenuation;\n"
"	specular *= attenuation;\n"
// calculate shadow
"	float shadow = ShadowCalculation(fs_in.FragPosLightSpace);\n"
// final fragment's color
"	vec3 result =  ambient + (1.0f - shadow) * (diffuse + specular);\n"
"	FragColor = vec4(result, 1.0f);\n"
"}\n";


// blinn
const char* blinn_vertex_shader = "#version 330 core\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoords;\n"
"out VS_OUT{\n"
"	vec3 FragPos;\n"
"	vec3 Normal;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}vs_out;\n"
// 
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"uniform mat4 lightSpaceMatrix;\n"
"void main()\n"
"{\n"
"	vs_out.FragPos = vec3(model * vec4(aPos, 1.0f));\n"
"	gl_Position = projection * view * model * vec4(aPos, 1.0f);\n"
"	vs_out.Normal = mat3(transpose(inverse(model))) * aNormal;\n"
"	vs_out.TexCoords = aTexCoords;\n"
// transformation from world space into light space
"	vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0);\n"
"}\n";
// with attenuation and Gamma correction
const char* blinn_fragment_shader = "#version 330 core\n"
"in VS_OUT {\n"
"	vec3 FragPos;\n"
"	vec3 Normal;\n"
"	vec2 TexCoords;\n"
"	vec4 FragPosLightSpace;\n"
"}fs_in;\n"
"out vec4 FragColor;\n"
"uniform vec3 viewPos;\n"
"struct Light {\n"
"	vec3 color;\n"
"	vec3 position;\n"
"	vec3 ambient;\n"
"	vec3 diffuse;\n"
"	vec3 specular;\n"
"	float constant;\n"
"	float linear;\n"
"	float quadratic;\n"
"};\n"
"struct Material {\n"
"	sampler2D diffuse;\n"
"	sampler2D specular;\n"
"	float shininess;\n"
"};\n"
"uniform sampler2D shadowMap;\n"
"uniform Light light;\n"
"uniform Material material;\n"
// calculate shadow
"float ShadowCalculation(vec4 fragPosLightSpace) {\n"
"	vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n"
"	projCoords = projCoords * 0.5 + 0.5;\n"
// closest depth
"	float closetDepth = texture(shadowMap, projCoords.xy).r;\n"
// current depth
"	float currentDepth = projCoords.z;\n"
"	vec3 normal = normalize(fs_in.Normal);\n"
"	vec3 lightDir = normalize(light.position - fs_in.FragPos);\n"
"	float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);\n"
// set shadow factor to be 
"	float shadow = 0.0;\n"
"	vec2 texelSize = 1.0 / textureSize(shadowMap, 0);\n"
"	for (int x = -1; x <= 1; ++x)\n"
"	{\n"
"		for (int y = -1; y <= 1; ++y)\n"
"		{\n"
"			float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n"
"			shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n"
"		}\n"
"	}\n"
"	shadow /= 9.0;\n"
// Keep the shadow at 0.0 when outside the far_plane region of the light's frustum.
"	if (projCoords.z > 1.0)\n"
"		shadow = 0.0;\n"
"	return shadow;\n"
"}\n"
"void main()\n"
"{\n"
// calculate ambient with diffuse texture (surely you can also use an ambient texture)
"	vec3 ambient = light.ambient * light.color * texture(material.diffuse, fs_in.TexCoords).rgb;\n"
// calculate normal and light direction
"	vec3 normal = normalize(fs_in.Normal);\n"
"	vec3 lightDirection = normalize(light.position - fs_in.FragPos);\n"
// calculate diffuse component with diffuse texture
"	float diffuseStrength = max(dot(normal, lightDirection), 0.0f);\n"
"	vec3 diffuse = light.diffuse * (diffuseStrength * light.color * texture(material.diffuse, fs_in.TexCoords).rgb);\n"
// calculate specular component with specular texture
"	vec3 viewDirection = normalize(viewPos - fs_in.FragPos);\n"
"	vec3 halfwayDirection = normalize(lightDirection + viewDirection);\n"
"	float specularStrength = pow(max(dot(normal, halfwayDirection), 0.0f), material.shininess);\n"
"	vec3 specular = light.specular * (specularStrength * texture(material.specular, fs_in.TexCoords).rgb * light.color);\n"
// calculate shadow
"	float shadow = ShadowCalculation(fs_in.FragPosLightSpace);\n"
// final fragment's color
"	vec3 result =  ambient + (1.0f - shadow) * (diffuse + specular);\n"
"	FragColor = vec4(result, 1.0f);\n"
"}\n";

// depth shader
const char* depth_vertex = "#version 330 core\n"
"layout (location = 0) in vec3 position;\n"
"uniform mat4 lightSpaceMatrix;\n"
"uniform mat4 model;\n"
"void main() {\n"
"	gl_Position = lightSpaceMatrix * model * vec4(position, 1.0f);\n"
"}\n";
// empty fragment shader
const char* depth_fragment = "#version 330 core\n"
"void main() {\n"
// 'cause will be automatically set as defualt
"	gl_FragDepth = gl_FragCoord.z;\n"
"}\n";